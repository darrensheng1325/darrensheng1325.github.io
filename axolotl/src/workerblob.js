"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.initSinglePlayerMode = initSinglePlayerMode;
function initSinglePlayerMode() {
    var _this = this;
    console.log('Initializing single player mode');
    try {
        // Create inline worker with the worker code
        var workerBlob = new Blob(["\n          // Worker code starts here\n          const WORLD_WIDTH = 10000;  // Changed from 2000 to 10000\n          const WORLD_HEIGHT = 2000;\n          const ENEMY_COUNT = 100;\n          const OBSTACLE_COUNT = 20;\n          const ENEMY_CORAL_PROBABILITY = 0.3;\n          const ENEMY_CORAL_HEALTH = 50;\n          const ENEMY_CORAL_DAMAGE = 5;\n          const PLAYER_MAX_HEALTH = 100;\n          const PLAYER_DAMAGE = 10;\n          const ITEM_COUNT = 10;\n          const MAX_INVENTORY_SIZE = 5;\n          const PLAYER_SIZE = 40;\n          const COLLISION_RADIUS = PLAYER_SIZE / 2;\n          const ENEMY_SIZE = 40;\n          const RESPAWN_INVULNERABILITY_TIME = 3000;\n          const KNOCKBACK_FORCE = 20;\n          const KNOCKBACK_RECOVERY_SPEED = 0.9;\n          const DECORATION_COUNT = 100;  // Number of palms to spawn\n          var BASE_XP_REQUIREMENT = 100;\n          var XP_MULTIPLIER = 1.5;\n          var MAX_LEVEL = 50;\n          var HEALTH_PER_LEVEL = 10;\n          var DAMAGE_PER_LEVEL = 2;\n          var DROP_CHANCES = {\n              common: 0.1, // 10% chance\n              uncommon: 0.2, // 20% chance\n              rare: 0.3, // 30% chance\n              epic: 0.4, // 40% chance\n              legendary: 0.5, // 50% chance\n              mythic: 0.75 // 75% chance\n          };\n\n          const ENEMY_TIERS = {\n              common: { health: 20, speed: 0.5, damage: 5, probability: 0.4 },\n              uncommon: { health: 40, speed: 0.75, damage: 10, probability: 0.3 },\n              rare: { health: 60, speed: 1, damage: 15, probability: 0.15 },\n              epic: { health: 80, speed: 1.25, damage: 20, probability: 0.1 },\n              legendary: { health: 100, speed: 1.5, damage: 25, probability: 0.04 },\n              mythic: { health: 150, speed: 2, damage: 30, probability: 0.01 }\n          };\n          var ZONE_BOUNDARIES = {\n              common: { start: 0, end: 2000 },\n              uncommon: { start: 2000, end: 4000 },\n              rare: { start: 4000, end: 6000 },\n              epic: { start: 6000, end: 8000 },\n              legendary: { start: 8000, end: 9000 },\n              mythic: { start: 9000, end: WORLD_WIDTH }\n          };\n          var ENEMY_SIZE_MULTIPLIERS = {\n              common: 1.0,\n              uncommon: 1.2,\n              rare: 1.4,\n              epic: 1.6,\n              legendary: 1.8,\n              mythic: 2.0\n          };\n\n          const players = {};\n          const enemies = [];\n          const obstacles = [];\n          const items = [];\n          const dots = [];\n          const decorations = [];\n          const sands = [];\n\n          // Helper function to get random position in a specific zone\n          function getRandomPositionInZone(zoneIndex) {\n              const zoneWidth = WORLD_WIDTH / 6;  // 6 zones\n              const startX = zoneIndex * zoneWidth;\n              \n              // For legendary and mythic zones, ensure they're in the rightmost areas\n              if (zoneIndex >= 4) {  // Legendary and Mythic zones\n                  const adjustedStartX = WORLD_WIDTH - (6 - zoneIndex) * (zoneWidth / 2);  // Start from right side\n                  return {\n                      x: adjustedStartX + Math.random() * (WORLD_WIDTH - adjustedStartX),\n                      y: Math.random() * WORLD_HEIGHT\n                  };\n              }\n              \n              return {\n                  x: startX + Math.random() * zoneWidth,\n                  y: Math.random() * WORLD_HEIGHT\n              };\n          }\n          function getXPFromEnemy(enemy) {\n              var tierMultipliers = {\n                  common: 10,\n                  uncommon: 20,\n                  rare: 40,\n                  epic: 80,\n                  legendary: 160,\n                  mythic: 320\n              };\n              return tierMultipliers[enemy.tier];\n          }\n          function addXPToPlayer(player, xp) {\n              if (player.level >= MAX_LEVEL)\n                  return;\n              player.xp += xp;\n              while (player.xp >= player.xpToNextLevel && player.level < MAX_LEVEL) {\n                  player.xp -= player.xpToNextLevel;\n                  player.level++;\n                  player.xpToNextLevel = calculateXPRequirement(player.level);\n                  handleLevelUp(player);\n              }\n              if (player.level >= MAX_LEVEL) {\n                  player.xp = 0;\n                  player.xpToNextLevel = 0;\n              }\n              socket.emit('xpGained', {\n                  playerId: player.id,\n                  xp: xp,\n                  totalXp: player.xp,\n                  level: player.level,\n                  xpToNextLevel: player.xpToNextLevel,\n                  maxHealth: player.maxHealth,\n                  damage: player.damage\n              });\n          }\n          function handleLevelUp(player) {\n              player.maxHealth += HEALTH_PER_LEVEL;\n              player.health = player.maxHealth;\n              player.damage += DAMAGE_PER_LEVEL;\n              socket.emit('levelUp', {\n                  playerId: player.id,\n                  level: player.level,\n                  maxHealth: player.maxHealth,\n                  damage: player.damage\n              });\n          }\n          function respawnPlayer(player) {\n              // Determine spawn zone based on player level without losing levels\n              var spawnX;\n              if (player.level <= 5) {\n                  spawnX = Math.random() * ZONE_BOUNDARIES.common.end;\n              }\n              else if (player.level <= 10) {\n                  spawnX = ZONE_BOUNDARIES.uncommon.start + Math.random() * (ZONE_BOUNDARIES.uncommon.end - ZONE_BOUNDARIES.uncommon.start);\n              }\n              else if (player.level <= 15) {\n                  spawnX = ZONE_BOUNDARIES.rare.start + Math.random() * (ZONE_BOUNDARIES.rare.end - ZONE_BOUNDARIES.rare.start);\n              }\n              else if (player.level <= 25) {\n                  spawnX = ZONE_BOUNDARIES.epic.start + Math.random() * (ZONE_BOUNDARIES.epic.end - ZONE_BOUNDARIES.epic.start);\n              }\n              else if (player.level <= 40) {\n                  spawnX = ZONE_BOUNDARIES.legendary.start + Math.random() * (ZONE_BOUNDARIES.legendary.end - ZONE_BOUNDARIES.legendary.start);\n              }\n              else {\n                  spawnX = ZONE_BOUNDARIES.mythic.start + Math.random() * (ZONE_BOUNDARIES.mythic.end - ZONE_BOUNDARIES.mythic.start);\n              }\n              // Reset health and position but keep level and stats\n              player.health = player.maxHealth;\n              player.x = spawnX;\n              player.y = Math.random() * WORLD_HEIGHT;\n              player.score = Math.max(0, player.score - 10); // Still lose some score\n              player.inventory = [];\n              player.isInvulnerable = true;\n              // Just notify about respawn without level loss\n              socket.emit('playerRespawned', player);\n              setTimeout(function () {\n                  player.isInvulnerable = false;\n              }, RESPAWN_INVULNERABILITY_TIME);\n          }\n          function moveEnemies() {\n              if (!enemies || !enemies.length) return;  // Guard against undefined enemies array\n              \n              enemies.forEach(enemy => {\n                  if (!enemy) return;  // Guard against undefined enemy objects\n                  \n                  try {\n                      // Apply knockback if it exists\n                      if (enemy.knockbackX) {\n                          enemy.knockbackX *= KNOCKBACK_RECOVERY_SPEED;\n                          enemy.x += enemy.knockbackX;\n                          if (Math.abs(enemy.knockbackX) < 0.1) enemy.knockbackX = 0;\n                      }\n                      if (enemy.knockbackY) {\n                          enemy.knockbackY *= KNOCKBACK_RECOVERY_SPEED;\n                          enemy.y += enemy.knockbackY;\n                          if (Math.abs(enemy.knockbackY) < 0.1) enemy.knockbackY = 0;\n                      }\n\n                      // Different movement patterns based on enemy type\n                      if (enemy.type === 'octopus') {\n                          // Random movement for octopus\n                          enemy.x += (Math.random() * 4 - 2) * (enemy.speed || 1);\n                          enemy.y += (Math.random() * 4 - 2) * (enemy.speed || 1);\n                      } else {\n                          // Directional movement for fish\n                          enemy.x += Math.cos(enemy.angle || 0) * 2 * (enemy.speed || 1);\n                          enemy.y += Math.sin(enemy.angle || 0) * 2 * (enemy.speed || 1);\n                      }\n\n                      // Keep enemies in their respective zones\n                      const zoneWidth = WORLD_WIDTH / 6;\n                      const tierZones = {\n                          common: 0,\n                          uncommon: 1,\n                          rare: 2,\n                          epic: 3,\n                          legendary: 4,\n                          mythic: 5\n                      };\n                      \n                      const zoneIndex = tierZones[enemy.tier] || 0;\n                      const zoneStartX = zoneIndex * zoneWidth;\n                      const zoneEndX = (zoneIndex + 1) * zoneWidth;\n                      \n                      // Add some overlap between zones (10% on each side)\n                      const overlap = zoneWidth * 0.1;\n                      const minX = Math.max(0, zoneStartX - overlap);\n                      const maxX = Math.min(WORLD_WIDTH, zoneEndX + overlap);\n                      \n                      // Constrain enemy position to its zone\n                      enemy.x = Math.max(minX, Math.min(maxX, enemy.x));\n                      enemy.y = Math.max(0, Math.min(WORLD_HEIGHT, enemy.y));\n\n                      // Randomly change fish direction occasionally\n                      if (enemy.type === 'fish' && Math.random() < 0.02) {\n                          enemy.angle = Math.random() * Math.PI * 2;\n                      }\n                  } catch (error) {\n                      console.error('Error moving enemy:', error, enemy);\n                  }\n              });\n\n              try {\n                  // Filter out any undefined enemies before emitting\n                  const validEnemies = enemies.filter(enemy => enemy !== undefined);\n                  socket.emit('enemiesUpdate', validEnemies);\n              } catch (error) {\n                  console.error('Error emitting enemies update:', error);\n              }\n          }\n\n          // Update creation functions to use zones\n          function createDecoration() {\n              const zoneIndex = Math.floor(Math.random() * 6);  // 6 zones\n              const pos = getRandomPositionInZone(zoneIndex);\n              return {\n                  x: pos.x,\n                  y: pos.y,\n                  scale: 0.5 + Math.random() * 1.5\n              };\n          }\n\n          function createEnemy() {\n              const tierRoll = Math.random();\n              let tier = 'common';\n              let cumulativeProbability = 0;\n              for (const [t, data] of Object.entries(ENEMY_TIERS)) {\n                  cumulativeProbability += data.probability;\n                  if (tierRoll < cumulativeProbability) {\n                      tier = t;\n                      break;\n                  }\n              }\n              const tierData = ENEMY_TIERS[tier];\n              \n              // Map tiers to specific zones, ensuring legendary and mythic are in the rightmost areas\n              const tierZones = {\n                  common: 0,\n                  uncommon: 1,\n                  rare: 2,\n                  epic: 3,\n                  legendary: 4,\n                  mythic: 5\n              };\n              \n              const pos = getRandomPositionInZone(tierZones[tier]);\n              \n              return {\n                  id: Math.random().toString(36).substr(2, 9),\n                  type: Math.random() < 0.5 ? 'octopus' : 'fish',\n                  tier,\n                  x: pos.x,\n                  y: pos.y,\n                  angle: Math.random() * Math.PI * 2,\n                  health: tierData.health,\n                  speed: tierData.speed,\n                  damage: tierData.damage,\n                  knockbackX: 0,\n                  knockbackY: 0\n              };\n          }\n\n          function createObstacle() {\n              const zoneIndex = Math.floor(Math.random() * 6);\n              const pos = getRandomPositionInZone(zoneIndex);\n              const isEnemy = Math.random() < ENEMY_CORAL_PROBABILITY;\n              return {\n                  id: Math.random().toString(36).substr(2, 9),\n                  x: pos.x,\n                  y: pos.y,\n                  width: 50 + Math.random() * 50,\n                  height: 50 + Math.random() * 50,\n                  type: 'coral',\n                  isEnemy,\n                  health: isEnemy ? ENEMY_CORAL_HEALTH : undefined\n              };\n          }\n\n          function createItem() {\n              const zoneIndex = Math.floor(Math.random() * 6);\n              const pos = getRandomPositionInZone(zoneIndex);\n              return {\n                  id: Math.random().toString(36).substr(2, 9),\n                  type: ['health_potion', 'speed_boost', 'shield'][Math.floor(Math.random() * 3)],\n                  x: pos.x,\n                  y: pos.y\n              };\n          }\n\n          function initializeGame(messageData) {\n              console.log('Initializing game state in worker');\n              \n              // Start player in the first zone (common)\n              players[socket.id] = {\n                  id: socket.id,\n                  x: WORLD_WIDTH / 12,  // Center of first zone\n                  y: WORLD_HEIGHT / 2,\n                  angle: 0,\n                  score: 0,\n                  velocityX: 0,\n                  velocityY: 0,\n                  health: PLAYER_MAX_HEALTH,\n                  inventory: [],\n                  isInvulnerable: true,\n                  level: 1,\n                  xp: 0,\n                  xpToNextLevel: 100,\n                  maxHealth: PLAYER_MAX_HEALTH,\n                  damage: PLAYER_DAMAGE\n              };\n\n              // Ensure specific number of legendary and mythic enemies\n              const legendaryCount = Math.floor(ENEMY_COUNT * 0.04);  // 4% of total\n              const mythicCount = Math.floor(ENEMY_COUNT * 0.01);     // 1% of total\n              \n              // Spawn legendary enemies\n              for (let i = 0; i < legendaryCount; i++) {\n                  const enemy = createEnemy();\n                  enemy.tier = 'legendary';\n                  const pos = getRandomPositionInZone(4);  // Zone 4 for legendary\n                  enemy.x = pos.x;\n                  enemy.y = pos.y;\n                  enemies.push(enemy);\n              }\n              \n              // Spawn mythic enemies\n              for (let i = 0; i < mythicCount; i++) {\n                  const enemy = createEnemy();\n                  enemy.tier = 'mythic';\n                  const pos = getRandomPositionInZone(5);  // Zone 5 for mythic\n                  enemy.x = pos.x;\n                  enemy.y = pos.y;\n                  enemies.push(enemy);\n              }\n              \n              // Spawn remaining enemies\n              const remainingCount = ENEMY_COUNT - legendaryCount - mythicCount;\n              for (let i = 0; i < remainingCount; i++) {\n                  enemies.push(createEnemy());\n              }\n\n              for (let i = 0; i < OBSTACLE_COUNT; i++) {\n                  obstacles.push(createObstacle());\n              }\n\n              for (let i = 0; i < ITEM_COUNT; i++) {\n                  items.push(createItem());\n              }\n\n              for (let i = 0; i < DECORATION_COUNT; i++) {\n                  decorations.push(createDecoration());\n              }\n\n              // Emit initial state\n              socket.emit('currentPlayers', players);\n              socket.emit('enemiesUpdate', enemies);\n              socket.emit('obstaclesUpdate', obstacles);\n              socket.emit('itemsUpdate', items);\n              socket.emit('decorationsUpdate', decorations);\n              socket.emit('playerMoved', players[socket.id]);\n          }\n\n          // Mock Socket class implementation\n          class MockSocket {\n              constructor() {\n                  this.eventHandlers = new Map();\n                  this.id = 'player1';\n              }\n              on(event, handler) {\n                  if (!this.eventHandlers.has(event)) {\n                      this.eventHandlers.set(event, []);\n                  }\n                  this.eventHandlers.get(event)?.push(handler);\n              }\n              emit(event, data) {\n                  self.postMessage({\n                      type: 'socketEvent',\n                      event,\n                      data\n                  });\n              }\n              getId() {\n                  return this.id;\n              }\n          }\n\n          const socket = new MockSocket();\n\n          // Message handler\n          self.onmessage = function(event) {\n              const { type, event: socketEvent, data } = event.data;\n              \n              switch (type) {\n                  case 'init':\n                      initializeGame(event.data);\n                      break;\n                  case 'socketEvent':\n                      switch (socketEvent) {\n          case 'playerMovement':\n              const player = players[socket.id];\n              if (player) {\n                  let newX = data.x;\n                  let newY = data.y;\n\n                  // Apply knockback to player position if it exists\n                  if (player.knockbackX) {\n                      player.knockbackX *= KNOCKBACK_RECOVERY_SPEED;\n                      newX += player.knockbackX;\n                      if (Math.abs(player.knockbackX) < 0.1) player.knockbackX = 0;\n                  }\n                  if (player.knockbackY) {\n                      player.knockbackY *= KNOCKBACK_RECOVERY_SPEED;\n                      newY += player.knockbackY;\n                      if (Math.abs(player.knockbackY) < 0.1) player.knockbackY = 0;\n                  }\n\n                  let collision = false;\n\n                  // Check collision with enemies first\n                  for (const enemy of enemies) {\n                      const enemySize = ENEMY_SIZE * ENEMY_SIZE_MULTIPLIERS[enemy.tier];\n                      \n                      if (\n                          newX < enemy.x + enemySize &&\n                          newX + PLAYER_SIZE > enemy.x &&\n                          newY < enemy.y + enemySize &&\n                          newY + PLAYER_SIZE > enemy.y\n                      ) {\n                          collision = true;\n                          console.log(enemy);\n                          if (true) {\n                              // Enemy damages player\n                              player.health -= enemy.damage;\n                              socket.emit('playerDamaged', { playerId: player.id, health: player.health });\n\n                              // Player damages enemy\n                              enemy.health -= player.damage;  // Use player.damage instead of PLAYER_DAMAGE\n                              socket.emit('enemyDamaged', { enemyId: enemy.id, health: enemy.health });\n\n                              // Calculate knockback direction\n                              const dx = enemy.x - newX;\n                              const dy = enemy.y - newY;\n                              const distance = Math.sqrt(dx * dx + dy * dy);\n                              const normalizedDx = dx / distance;\n                              const normalizedDy = dy / distance;\n\n                              // Apply knockback to player's position immediately\n                              newX -= normalizedDx * KNOCKBACK_FORCE;\n                              newY -= normalizedDy * KNOCKBACK_FORCE;\n                              \n                              // Store knockback for gradual recovery\n                              player.knockbackX = -normalizedDx * KNOCKBACK_FORCE;\n                              player.knockbackY = -normalizedDy * KNOCKBACK_FORCE;\n\n                              // Check if enemy dies\n                              if (enemy.health <= 0) {\n                                  const index = enemies.findIndex(e => e.id === enemy.id);\n                                  if (index !== -1) {\n                                      // Award XP before removing the enemy\n                                      const xpGained = getXPFromEnemy(enemy);\n                                      addXPToPlayer(player, xpGained);\n                                      \n                                      // Check for item drop and add directly to inventory\n                                      const dropChance = DROP_CHANCES[enemy.tier];\n                                      if (Math.random() < dropChance && player.inventory.length < MAX_INVENTORY_SIZE) {\n                                          // Create item and add directly to player's inventory\n                                          const newItem = {\n                                              id: Math.random().toString(36).substr(2, 9),\n                                              type: ['health_potion', 'speed_boost', 'shield'][Math.floor(Math.random() * 3)],\n                                              x: enemy.x,\n                                              y: enemy.y\n                                          };\n                                          player.inventory.push(newItem);\n                                          \n                                          // Notify about item pickup\n                                          socket.emit('inventoryUpdate', player.inventory);\n                                          socket.emit('itemCollected', { \n                                              playerId: player.id, \n                                              itemId: newItem.id,\n                                              itemType: newItem.type \n                                          });\n                                      }\n                                      \n                                      // Remove the dead enemy and create a new one\n                                      enemies.splice(index, 1);\n                                      socket.emit('enemyDestroyed', enemy.id);\n                                      enemies.push(createEnemy());\n                                  }\n                              }\n\n                              // Check if player dies\n                              if (player.health <= 0) {\n                                  respawnPlayer(player);\n                                  socket.emit('playerDied', player.id);\n                                  socket.emit('playerRespawned', player);\n                                  return;\n                              }\n                          }\n                          break;\n                      }\n                  }\n\n                  // Check collision with obstacles\n                  for (const obstacle of obstacles) {\n                      if (\n                          newX + PLAYER_SIZE > obstacle.x && \n                          newX < obstacle.x + obstacle.width &&\n                          newY + PLAYER_SIZE > obstacle.y &&\n                          newY < obstacle.y + obstacle.height\n                      ) {\n                          collision = true;\n                          if (obstacle.isEnemy) {\n                              player.health -= ENEMY_CORAL_DAMAGE;\n                              socket.emit('playerDamaged', { playerId: player.id, health: player.health });\n\n                              if (player.health <= 0) {\n                                  respawnPlayer(player);\n                                  socket.emit('playerDied', player.id);\n                                  socket.emit('playerRespawned', player);\n                                  return; // Exit early if player dies\n                              }\n                          }\n                          break;\n                      }\n                  }\n\n                  // Update player position\n                  // Even if there was a collision, we want to apply the knockback\n                  player.x = Math.max(0, Math.min(WORLD_WIDTH - PLAYER_SIZE, newX));\n                  player.y = Math.max(0, Math.min(WORLD_HEIGHT - PLAYER_SIZE, newY));\n                  player.angle = data.angle;\n                  player.velocityX = data.velocityX;\n                  player.velocityY = data.velocityY;\n\n                  // Always emit the player's position\n                  socket.emit('playerMoved', player);\n              }\n              break;\n\n          case 'collectItem':\n              var itemIndex = items.findIndex(function (item) { return item.id === data.itemId; });\n              if (itemIndex !== -1 && players[socket.id].inventory.length < MAX_INVENTORY_SIZE) {\n                  var item = items[itemIndex];\n                  players[socket.id].inventory.push(item);\n                  items.splice(itemIndex, 1);\n                  items.push(createItem());\n                  socket.emit('itemCollected', { playerId: socket.id, itemId: data.itemId });\n              }\n              break;\n          case 'useItem':\n              var playerUsingItem = players[socket.id];\n              var inventoryIndex = playerUsingItem.inventory.findIndex(function (item) { return item.id === data.itemId; });\n              if (inventoryIndex !== -1) {\n                  var item = playerUsingItem.inventory[inventoryIndex];\n                  playerUsingItem.inventory.splice(inventoryIndex, 1);\n                  switch (item.type) {\n                      case 'health_potion':\n                          playerUsingItem.health = Math.min(playerUsingItem.health + 50, PLAYER_MAX_HEALTH);\n                          break;\n                      case 'speed_boost':\n                          // Implement speed boost\n                          break;\n                      case 'shield':\n                          // Implement shield\n                          break;\n                  }\n                  socket.emit('itemUsed', { playerId: socket.id, itemId: data.itemId });\n              }\n              break;\n          case 'requestRespawn':\n              var deadPlayer = players[socket.id];\n              if (deadPlayer) {\n                  respawnPlayer(deadPlayer);\n              }\n              break;\n          // ... (handle other socket events)\n      }\n      break;\n  }\n};\n\n          // Start enemy movement interval\nsetInterval(() => {\n  try {\n      moveEnemies();\n  } catch (error) {\n      console.error('Error in moveEnemies interval:', error);\n  }\n}, 100);\n      "], { type: 'application/javascript' });
        // Create worker from blob
        this.worker = new Worker(URL.createObjectURL(workerBlob));
        // Load saved progress
        var savedProgress = this.loadPlayerProgress();
        console.log('Loaded saved progress:', savedProgress);
        // Create mock socket
        var mockSocket = {
            id: 'player1',
            emit: function (event, data) {
                var _a;
                console.log('Emitting event:', event, data);
                (_a = _this.worker) === null || _a === void 0 ? void 0 : _a.postMessage({
                    type: 'socketEvent',
                    event: event,
                    data: data
                });
            },
            on: function (event, handler) {
                console.log('Registering handler for event:', event);
                _this.socketHandlers.set(event, handler);
            },
            disconnect: function () {
                var _a;
                (_a = _this.worker) === null || _a === void 0 ? void 0 : _a.terminate();
            }
        };
        // Use mock socket
        this.socket = mockSocket;
        // Set up socket listeners
        this.setupSocketListeners();
        // Handle worker messages
        this.worker.onmessage = function (event) {
            var _a = event.data, type = _a.type, socketEvent = _a.event, data = _a.data;
            //console.log('Received message from worker:', type, socketEvent, data);
            if (type === 'socketEvent') {
                var handler = _this.socketHandlers.get(socketEvent);
                if (handler) {
                    handler(data);
                }
            }
        };
        // Initialize game
        console.log('Sending init message to worker with saved progress');
        this.worker.postMessage({
            type: 'init',
            savedProgress: savedProgress
        });
    }
    catch (error) {
        console.error('Error initializing worker:', error);
    }
}
